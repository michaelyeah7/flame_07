// $Id: control_demo.c,v 1.12 2005/12/16 16:14:22 garthz Exp $
// control_demo : a demonstration controller for the Flame biped robot
//
// Copyright (c) 2005 Garth Zeglin. Provided under the terms of the
// GNU General Public License as included in the top level directory.
//
// This file defines front panel switches as follows:
//
//		TOGGLE0		TOGGLE1		TOGGLE2		TOGGLE3
//		controller			                save data
//		on/off						up = yes

//		PUSHBUTTON0	PUSHBUTTON1	PUSHBUTTON2	PUSHBUTTON3	
//		shutdown	         	        	clear


#include <stdio.h>
#include <asm/io.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#include <math.h>
#include <string.h>
#include <pthread.h>
#include <stdarg.h>
#include <signal.h>
#include <sys/types.h>
#include <regex.h>

#if USE_DMALLOC
#include <dmalloc.h>   // malloc debugging
#endif

#include <rtai_lxrt.h>

#include <hardware_drivers/FlameIO.h>
#include <utility/utility.h>
#include <utility/dataset.h>
#include <utility/record.h>
#include <utility/system_state_var.h>

#include <real_time_support/RTAI_user_space_realtime.h>
#include <real_time_support/RTAI_mailbox_messaging.h>
#include <real_time_support/UDP_messaging.h>
#include <real_time_support/protocol_version.h>

// definitions for the big structures of control state
#include <hardware_drivers/FlameIO_defs.h>

// application header files
#include "system.h"
#include "local_protocol_version.h"
#include "message_format.h"
#include "control_demo.h"

/****************************************************************/
#define SAMPLING_RATE 1000      // Hz
#define TIMER_PERIOD (1000000000 / SAMPLING_RATE )  // nsec
#define CONTROL_DT    (1.0 / SAMPLING_RATE)         // seconds

#define NAME "control demo"

// opaque handle for the real time control thread task
static struct realtime_task *control_task = NULL;

/****************************************************************/
FlameIO_state_t s;        // the global hardware state structure (i.e. blackboard)
FlameIO_params_t params;  // the hardware parameters structure 
controller_state_t c;     // the controller state blackboard

// Define a table which describes the name and location of the
// global state variables.  The entries are generated by
// different makevars scripts.

static system_state_var_t system_vars[] = {
  // include entries generated for our controller code
#include "sysvars.h"

  // include entries generated for the hardware driver code
#include <hardware_drivers/FlameIO_sysvars.h>

  // a final entry to mark the end of the list
  { NULL, SYS_NOTYPE, NULL }
};

/****************************************************************/
// Data logging buffer
#define RINGLEN 30000    // 30 seconds at 1 kHz
static dataset_t *ring_buffer = NULL;

/****************************************************************/
static FlameIO io;               // a static area to hold the driver data

// Pointers to message queues.
static message_port *rt_out_port = NULL;   
static message_port *rt_in_port = NULL;

// Flag to indicate destination of console messages.
static int console_on_ports = 0;

/****************************************************************/
// Provide a local version of errprintf to override the one in
// the utility library.  This is necessary so that the normal Linux system
// calls are not used.

#define CONSOLE_BUFFER_LENGTH 1024
static char console_buffer[ CONSOLE_BUFFER_LENGTH ];

void errprintf(char *format, ...)
{
  va_list args;
  va_start( args, format);

  if ( !console_on_ports ) {
    // Normal stdout stream output.  Add a header with a name and a time stamp.
    char nowstr[26];
    time_t now = time(NULL);

    strncpy( nowstr, ctime(&now)+11, 8);   // ctime format: "Wed Jun 30 21:49:08 1993\n"
    nowstr[8] = 0;
    fprintf(stderr, "%s error %s: ", NAME, nowstr);
    vfprintf(stderr, format, args);
    fflush(stderr);

  } else {
    // Send console messages through the real time ports. The
    // origin of the messages will be obvious from context, no
    // need to add the program name.
    strcpy( console_buffer, "error: ");
    vsnprintf( console_buffer + strlen( console_buffer ), CONSOLE_BUFFER_LENGTH - strlen( console_buffer), format, args );
    send_print( rt_out_port, console_buffer );
  }
  va_end(args);
}

/****************************************************************/
// Provide a local version of logprintf to override the one in
// the utility library.
void logprintf(char *format, ...)
{
  va_list args;
  va_start(args, format);

  if ( !console_on_ports ) {
    // normal stdout stream
    fprintf(stdout, "%s: ", NAME);
    vfprintf(stdout, format, args);
    fflush(stderr);

  } else {
    // Send console messages through the real time ports. The
    // origin of the messages will be obvious from context, no
    // need to add a header.
    vsnprintf( console_buffer, CONSOLE_BUFFER_LENGTH, format, args );
    send_print( rt_out_port, console_buffer );
  }

  va_end(args);
}


/****************************************************************/
// This may help avoid page faults, see the mlockall man page.
static void force_stack_growth(void)
{
#define STACKINCREMENT 100*1024
  char large_array[ STACKINCREMENT ];
  large_array[ STACKINCREMENT-1 ] = 0x55;
}

/****************************************************************/
// define the matrix with the previous q's here. They are needed for the velocity estimator.
// They are defined here so they will not go to the ring buffer and therefore will not consume that much memory.
// However, after using this for a couple of times it turned out that the processor load went from 45% to 65%!
// This is probably due to the style of programming. If you know how to improve it... please do so.

# define LENGTH_QPREV 10 //10 might be short, but is maintained for now due to the extra processor load it requires

static float hipx_qprev[ LENGTH_QPREV ];
static float l_hipy_qprev[ LENGTH_QPREV ];
static float l_knee_qprev[ LENGTH_QPREV ];
static float l_anklex_qprev[ LENGTH_QPREV ];
static float l_ankley_qprev[ LENGTH_QPREV ];
static float l_hipymot_qprev[ LENGTH_QPREV ];
static float l_kneemot_qprev[ LENGTH_QPREV ];
static float l_ankleymot_qprev[ LENGTH_QPREV ];
static float r_hipy_qprev[ LENGTH_QPREV ];
static float r_knee_qprev[ LENGTH_QPREV ];
static float r_anklex_qprev[ LENGTH_QPREV ];
static float r_ankley_qprev[ LENGTH_QPREV ];
static float r_hipymot_qprev[ LENGTH_QPREV ];
static float r_kneemot_qprev[ LENGTH_QPREV ];
static float r_ankleymot_qprev[ LENGTH_QPREV ];


/****************************************************************/
// A velocity estimator with adaptive windowing to recover velocity from encoders.
// This is inline code which is based on the algorithm of Janabi-Sharifi and Hayward (2000).
static inline void apply_velocity_estimator( float (*q_temp)[ LENGTH_QPREV ], float *q, float *qd, float *d, float dt )
{ 
  int i = 1;
  int m = 1;
  int all_points_within_uncertaintyband = 1;
  float diff = 0.0;
  float q_interp = 0.0;
  float b = 0.0;
  float sum = *q;
  float sumtot = 0.0;
  for ( i = 1; ( all_points_within_uncertaintyband == 1 && i < (LENGTH_QPREV+1) ) ; i++ ){       

    sum += (*q_temp)[i-1];
    sumtot += (*q_temp)[i-1] * i;                  // step 2 needed for best fit FOAW
    b = (i*sum-2*sumtot)/(dt*(i+2)*i*(i+1)/6);     // step 2 and 3 of paper "Janabi-Sharifi-2000.pdf"

    for ( m = 1; m < i; m++ ) {
      q_interp = *q - b*m*dt; 
      diff = q_interp - (*q_temp)[m-1];

      // step 4, if the b-line doesnt go trough the uncertainty band window (either above or below)
      if ((diff*diff) > 2*(*d*(*d)) ) {              // comparing the absolute values // 2times is a test 
	  all_points_within_uncertaintyband = 0;
	  break;
	}
      }
  }
  *qd = b;

  // shift the q in the q_temp-matrix down
  for (i = 1; i < LENGTH_QPREV; i++){
    (*q_temp)[i] = (*q_temp)[i-1];
  }

  (*q_temp)[0]   = *q;
}

/*******************************************************************/
// Now check if it works by comparing it to the old velocity estimator
static inline void apply_velocity_estimator_old ( float (*q_temp)[LENGTH_QPREV], float *q, float *qdold )
{   
  float diff =  *q - (*q_temp)[1]; // q_prev was already shifted down by the new *q, so q_prev[1] is the latest one before *q
  *qdold = diff / CONTROL_DT;
}
/*******************************************************************/
// Compute the velocity estimator for all encoder inputs.
static void update_velocity_estimators(void)
{
  apply_velocity_estimator( &hipx_qprev       , &s.q.hipx       , &s.qd.hipx       , &params.scale.q.hipx       , c.dt);
  apply_velocity_estimator( &l_hipy_qprev     , &s.q.l.hipy     , &s.qd.l.hipy     , &params.scale.q.l.hipy     , c.dt);
  apply_velocity_estimator( &l_knee_qprev     , &s.q.l.knee     , &s.qd.l.knee     , &params.scale.q.l.knee     , c.dt);
  apply_velocity_estimator( &l_ankley_qprev   , &s.q.l.ankley   , &s.qd.l.ankley   , &params.scale.q.l.ankley   , c.dt);
  apply_velocity_estimator( &l_anklex_qprev   , &s.q.l.anklex   , &s.qd.l.anklex   , &params.scale.q.l.anklex   , c.dt);
  apply_velocity_estimator( &l_hipymot_qprev  , &s.q.l.hipymot  , &s.qd.l.hipymot  , &params.scale.q.l.hipymot  , c.dt);
  apply_velocity_estimator( &l_kneemot_qprev  , &s.q.l.kneemot  , &s.qd.l.kneemot  , &params.scale.q.l.kneemot  , c.dt);
  apply_velocity_estimator( &l_ankleymot_qprev, &s.q.l.ankleymot, &s.qd.l.ankleymot, &params.scale.q.l.ankleymot, c.dt);
  apply_velocity_estimator( &r_hipy_qprev     , &s.q.r.hipy     , &s.qd.r.hipy     , &params.scale.q.r.hipy     , c.dt);
  apply_velocity_estimator( &r_knee_qprev     , &s.q.r.knee     , &s.qd.r.knee     , &params.scale.q.r.knee     , c.dt);
  apply_velocity_estimator( &r_ankley_qprev   , &s.q.r.ankley   , &s.qd.r.ankley   , &params.scale.q.r.ankley   , c.dt);
  apply_velocity_estimator( &r_anklex_qprev   , &s.q.r.anklex   , &s.qd.r.anklex   , &params.scale.q.r.anklex   , c.dt);
  apply_velocity_estimator( &r_hipymot_qprev  , &s.q.r.hipymot  , &s.qd.r.hipymot  , &params.scale.q.r.hipymot  , c.dt);
  apply_velocity_estimator( &r_kneemot_qprev  , &s.q.r.kneemot  , &s.qd.r.kneemot  , &params.scale.q.r.kneemot  , c.dt);
  apply_velocity_estimator( &r_ankleymot_qprev, &s.q.r.ankleymot, &s.qd.r.ankleymot, &params.scale.q.r.ankleymot, c.dt);

  // To see the difference with the old velocity estimator. This can be deleted when it turns out that the new one works better
  apply_velocity_estimator_old( &hipx_qprev      , &s.q.hipx     , &s.qdold.hipx     );
  apply_velocity_estimator_old( &l_hipy_qprev    , &s.q.l.hipy   , &s.qdold.l.hipy   );
  apply_velocity_estimator_old( &l_knee_qprev    , &s.q.l.knee   , &s.qdold.l.knee   ); 
  apply_velocity_estimator_old( &l_ankley_qprev  , &s.q.l.ankley , &s.qdold.l.ankley ); 
  apply_velocity_estimator_old( &l_anklex_qprev  , &s.q.l.anklex , &s.qdold.l.anklex );
  apply_velocity_estimator_old( &r_hipy_qprev    , &s.q.r.hipy   , &s.qdold.r.hipy   );
  apply_velocity_estimator_old( &r_knee_qprev    , &s.q.r.knee   , &s.qdold.r.knee   );
  apply_velocity_estimator_old( &r_ankley_qprev  , &s.q.r.ankley , &s.qdold.r.ankley ); 
  apply_velocity_estimator_old( &r_anklex_qprev  , &s.q.r.anklex , &s.qdold.r.anklex );
  
}
/****************************************************************/
// Fill vel_estim with zeros
static inline void fill_velocity_memory ( float (*qprev)[ LENGTH_QPREV ] )
{
  int k;
  for ( k = 0; k < LENGTH_QPREV ; k++ ){
    (*qprev)[k] = 0.0;
  }
}
 
/****************************************************************/
// Initialize the velocity memory. This matrix needs to be filled 
// with many zeros before the controller starts.
static void init_velocity_memory(void)
{
  fill_velocity_memory( &hipx_qprev        );
  fill_velocity_memory( &l_hipy_qprev      );
  fill_velocity_memory( &l_knee_qprev      );
  fill_velocity_memory( &l_ankley_qprev    );
  fill_velocity_memory( &l_anklex_qprev    );
  fill_velocity_memory( &l_hipymot_qprev   );
  fill_velocity_memory( &l_kneemot_qprev   );
  fill_velocity_memory( &l_ankleymot_qprev );
  fill_velocity_memory( &r_hipy_qprev      );
  fill_velocity_memory( &r_knee_qprev      );
  fill_velocity_memory( &r_ankley_qprev    );
  fill_velocity_memory( &r_anklex_qprev    );
  fill_velocity_memory( &r_hipymot_qprev   );
  fill_velocity_memory( &r_kneemot_qprev   );
  fill_velocity_memory( &r_ankleymot_qprev );
}

/****************************************************************/
// Initialize default control state.  This is done before PARAMS
// is read so the file can override the default values.
static void initialize_control_state (void)
{
  c.mode = MODE_INIT;
  c.t = 0;
  c.dt = CONTROL_DT;

  // c.record_dt = 0.001;
  c.timing.sensor_processing = 0.001;
  c.timing.total_cycle = 0.001;
  c.LEDS = 0;

  // initialize the various controller pieces
  init_joint_controllers(); // joint.c
  init_standing_controller(); // standing.c
  init_demo_controller(); // demo.c
  init_exercise_controller(); // exercise.c
  init_start_walking_controller(); // start-walking.c. This is also needed for the walking controller

}
/****************************************************************/
// Applying a tau limit to the controller.
static inline void apply_tau_limit( float *tau, float joint_ratio, float gear_ratio, int turbo_boost )
{
  // The limit is determined by the max amount of current (2.75 A)
  float max_current = 2.75;  
  float limit = 0.0;
  if (turbo_boost) max_current = 4.0;
  limit = max_current * MAXON_RE35_TORQUE_CONSTANT * joint_ratio * gear_ratio;
  if ( *tau >  limit ) { *tau =  limit; }
  if ( *tau < -limit ) { *tau = -limit; }
}
/****************************************************************/
// Utility to help manage the mode state machine.
static inline void mode_transition( int newmode )
{
  c.mode = -newmode;
  c.t_mode = c.t;    // record a timestamp
}
static float mode_time_elapsed( void )
{
  return c.t - c.t_mode;
}
/****************************************************************/
// This function will be called at regular intervals.
// No system calls are allowed inside this function. 
// This function returns true if the periodic calls should continue.

static int realtime_thread( long long timestamp, void *userdata )
{
  static int next_serial = 0;

  // Time stamp to provide an origin for the time axis.
  static RTIME start_of_execution;
  static int start_of_execution_valid = 0; 
  
  struct sensor_message_t sensormsg;
  union message_t msg;
  RTIME start_of_cycle, end_of_sensor_reading, end_of_cycle;
  int channel;
  int mode_init = 0;      // true if a mode is being executed for the first iteration

  /****************************************************************/
  // Read all inputs.
  start_of_cycle = (RTIME) timestamp;
  FlameIO_read_all_sensors( &io, &params, &s );
  end_of_sensor_reading = rt_get_cpu_time_ns();

  // Capture the time of the first iteration
  if ( !start_of_execution_valid ) {
    start_of_execution = start_of_cycle;
    start_of_execution_valid = 1;
  }

  // Extract a clock value in seconds.
  c.t = 1e-9 * (start_of_cycle - start_of_execution);

  /****************************************************************/
  // Perform all control actions.
  update_velocity_estimators();

  // Filter the motor voltage with a simple clamped first order filter.
  {
    float err = s.battery.mot_sw - c.mot_sw_filt;
    if ( err > 2.0 ) err = 2.0 ; else if ( err < -2.0 ) err = -2.0;
    c.mot_sw_filt += 0.1 * err;  // simple first order filter
  }    

  // -------------------------------
  // Detect the first iteration.
  if ( c.mode == MODE_INIT) mode_transition( MODE_STARTUP );

  // Detect the first iteration of a mode.
  if ( c.mode < 0 ) {
    c.mode = -c.mode;
    mode_init = 1;
  }

  // Mode dependent actions
  switch ( c.mode ) {

    // ------------------------------
  case MODE_STARTUP: 
    if ( mode_init ) {
      logprintf("entered STARTUP mode.\n");
      if ( FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE0 ) ) {
	logprintf("warning: RUN/STOP initially set to RUN, waiting for STOP.\n"); 
      }
    }
    if ( !FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE0 )) {
      mode_transition( MODE_IDLE );
    }
    // by default, make sure the motor power relay is always forced off
    FlameIO_write_power_control_outputs( &io, FLAME_MOTOR_POWER_OFF );
    s.powered = 0;

    break;

    // ------------------------------
  default:
    c.mode = MODE_IDLE;
    logprintf( "invalid control mode %d, resetting to IDLE.\n", c.mode );
    // fall through to IDLE

  case MODE_IDLE:

    if ( mode_init ) {
      logprintf("entered IDLE mode.\n IDLE     = toggle 1 down and 2 down.\n Exercise = toggle 1 down and 2 up.\n Standing = toggle 1 up and 2 down.\n IDLE   = toggle 1 up and 2 up\n");
    }
    s.powered = 0; // turn off all motor driver enable flags
    c.LEDS &= ~LED0;

    // zero out all the torque values
    s.tau.hipx     = 0.0; 
    s.tau.l.hipy   = 0.0; 
    s.tau.l.knee   = 0.0; 
    s.tau.l.ankley = 0.0; 
    s.tau.r.hipy   = 0.0; 
    s.tau.r.knee   = 0.0; 
    s.tau.r.ankley = 0.0; 

    if ( FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE0 ) ) {
      mode_transition( MODE_POWER_UP_DRIVERS );
    }
    
    // by default, make sure the motor power relay is always forced off
    FlameIO_write_power_control_outputs( &io, FLAME_MOTOR_POWER_OFF );

    // Shortcut when not powering the motor drivers (for testing)
    // Do not forget to comment the power down part in the cases themself!
    // mode_transition( MODE_EXERCISE );
    break;

    // ------------------------------
  case MODE_BEGIN_SHUTDOWN:

    // tell the monitor we are quitting
    send_signal ( rt_out_port, MSG_SHUTDOWN );

    // zero out all the torque values
    s.tau.hipx     = 0.0; 
    s.tau.l.hipy   = 0.0; 
    s.tau.l.knee   = 0.0; 
    s.tau.l.ankley = 0.0; 
    s.tau.r.hipy   = 0.0; 
    s.tau.r.knee   = 0.0; 
    s.tau.r.ankley = 0.0; 

    // make sure motors are off
    s.powered = 0;
    
    // make sure the LEDS are off
    c.LEDS = 0;

    // make sure the motor power relay is always forced off, and the motor power on is not enabled
    FlameIO_write_power_control_outputs( &io, FLAME_MOTOR_POWER_OFF );

    // this could do anything else to safely turn off the machine, or take some cycles to do so.

    // finish the shutdown, the loop will exit this cycle
    c.mode = MODE_SHUTDOWN;
    break;

  case MODE_SHUTDOWN:
    // this case shouldn't actually be reached, since once the
    // mode is entered the loop will exit for the last time.
    break;


    // ------------------------------
  case MODE_POWER_UP_DRIVERS:
    if ( mode_init ) {
      logprintf( "powering up drivers.\n\n Press button 1 to start EXERCISE mode...\nPress button 2 to go to standing\n" );
      s.powered = 0;  // no drivers enabled
      FlameIO_enable_motor_drivers( &io, s.powered );
      FlameIO_write_power_control_outputs( &io, FLAME_MOTOR_POWER_ON );
    }

    // zero out all the torque values
    s.tau.hipx     = 0.0; 
    s.tau.l.hipy   = 0.0; 
    s.tau.l.knee   = 0.0; 
    s.tau.l.ankley = 0.0; 
    s.tau.r.hipy   = 0.0; 
    s.tau.r.knee   = 0.0; 
    s.tau.r.ankley = 0.0; 

    // Wait a short time for the voltage to stabilize before continuing.  
    if ( mode_time_elapsed() > 0.2 ) {
      static int debounce = 0;
      FlameIO_write_power_control_outputs( &io, 0 );
      
      if ( FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON1 )) {
	debounce++;	
	if ( debounce = 5 ) {
	  mode_transition( MODE_EXERCISE );
	}
      }
      if ( FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON2 )) {
	debounce++;
	if ( debounce == 5 ) {
	  logprintf("recalibrating the motor encoder offsets.\n");
	  // Now it is assumed that the robot did an exercise to find the indexpulses before with the computer still on. 
	  // It knows its indexpositions and only needs to reset the motor positions equal to the joint positions. 

	  // the motors can rotate more than once per rotation, so assume that the springs are relaxed and just null
	  // the difference between the joint and motor encoders; this assumes that the joints have already been moved
	  // to find the index pulses
	  params.offset.q.l.hipymot    +=  s.q.l.hipy   - s.q.l.hipymot;
	  params.offset.q.l.kneemot    +=  s.q.l.knee   - s.q.l.kneemot;
	  params.offset.q.l.ankleymot  +=  s.q.l.ankley - s.q.l.ankleymot;
	  params.offset.q.r.hipymot    +=  s.q.r.hipy   - s.q.r.hipymot;
	  params.offset.q.r.kneemot    +=  s.q.r.knee   - s.q.r.kneemot;
	  params.offset.q.r.ankleymot  +=  s.q.r.ankley - s.q.r.ankleymot;

	  mode_transition( MODE_STANDING );
	}
      }
    }

#if 0
    // Wait for the voltage to stabilize before continuing.
    if ( c.mot_sw_filt > FLAME_STABLE_MOTOR_VOLTAGE ) {
      logprintf( "stable motor voltage detected.\n");
      FlameIO_write_power_control_outputs( &io, 0 );
      if (FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON1 )) { 
	mode_transition( MODE_DEMO );
      }
    }

    // A timeout on the power supply power up.
    if ( mode_time_elapsed() > 1.0 ) {
      logprintf( "motor voltage failed to stabilize.\n");
      FlameIO_write_power_control_outputs( &io, 0 );
      mode_transition( MODE_POWER_DN_DRIVERS );
    }
#endif      
    break;

    // ------------------------------
  case MODE_POWER_DN_DRIVERS:
    if ( mode_init ) {
      logprintf( "powering down drivers.\n" );
      s.powered = 0;  // no drivers enabled
      FlameIO_enable_motor_drivers( &io, s.powered );
      FlameIO_write_power_control_outputs( &io, FLAME_MOTOR_POWER_OFF );
    }

    // zero out all the torque values
    s.tau.hipx     = 0.0; 
    s.tau.l.hipy   = 0.0; 
    s.tau.l.knee   = 0.0; 
    s.tau.l.ankley = 0.0; 
    s.tau.r.hipy   = 0.0; 
    s.tau.r.knee   = 0.0; 
    s.tau.r.ankley = 0.0; 
    
    // This could wait for the voltages to stabilize near zero before continuing, but 
    // instead just enforces a short delay.
    if ( mode_time_elapsed() > 0.2 ) {
      
      // Leave the MOTOR_POWER_OFF output active to force the relay voltage to zero; this
      // compensates for the residual current through the power on drive transistor Q3.
      mode_transition( MODE_IDLE );
    }
    break;

    // ------------------------------
    // DO NOT USE MODE_DEMO! THIS IS OLD AND DOES NOT WORK PROPERLY.
  case MODE_DEMO:
    if ( mode_init ) {
      logprintf("So you want the DEMO mode?\n Press push button 1 to start demo.\n");
      logprintf("press push button 2 to advance through motor activation states.\n");
      c.LEDS |= LED0;
    }

    if ( !FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE0 ) ) {
      mode_transition( MODE_POWER_DN_DRIVERS );
    }

    // Cycle through different motor activation statesc as the button is pressed.
    {
      static int debounce = 0;
      if (FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON2 )) {
	c.LEDS |= LED2;
	debounce++;
	if ( debounce == 5 ) {
	  switch ( s.powered ) {
	  case 0:                 s.powered = 1; break;
	  case FLAME_LKNEE_MOTOR: s.powered = FLAME_RANKLEY_MOTOR; break;
	  case FLAME_HIPX_MOTOR:  s.powered = FLAME_ALL_MOTORS; break;
	  case FLAME_ALL_MOTORS:  s.powered = 0; break;
	  default:                s.powered <<= 1; break;
	  }
	  logprintf( "s.powered = 0x%02x\n", s.powered );
	}
      } else {
	debounce = 0;
	c.LEDS &= ~LED2;
      }
    }

    // now run the controller itself
    update_demo_controller(); // demo.c
    break;

    // ------------------------------
  case MODE_STANDING:
    if ( mode_init ) {
      logprintf("entered STANDING mode.\n");
      // reset the controller state machine
      c.standing.inx = 0;
      c.LEDS |= LED0;
    }

    if ( c.standing.inx == S_STAND_CONTROL &&
	 ( FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON1 ) && FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE1))) {
      if ((s.foot.l.back.count > 100 || s.foot.l.front.count > 100) && 
	  (s.foot.r.front.count > 100 || s.foot.r.back.count > 100))
	{
	  mode_transition( MODE_START_WALKING );  
	}
    }
    if ( c.standing.inx == S_STAND_CONTROL &&
	 ( FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON1 ))) {
      if ((s.foot.l.back.count > 100 || s.foot.l.front.count > 100) && 
	  (s.foot.r.front.count > 100 || s.foot.r.back.count > 100))
	{
	  mode_transition( MODE_WALKING );  
	}
    }
    //power down if the RUN/STOP switch goes to STOP
    if ( !FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE0 ) ) {
      c.LEDS &= ~LED0;
      mode_transition( MODE_POWER_DN_DRIVERS );
    } else {
      update_standing_controller(); // standing.c
    }
   break;

    // ------------------------------
    // Exercise controller; the code is in exercise.c
  case MODE_EXERCISE:
    if ( mode_init ) {
      logprintf("entered EXERCISE mode.\n");

      // reset the controller state machine
      c.exercise.inx = S_BEGIN;
      c.LEDS |= LED0;

    }
    if ( c.exercise.inx == S_END )
      {
      // debounce the "recalibrate" button
	static int debounce = 0;
	if ( FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON1 )) {
	  c.LEDS |= LED1;
	  debounce++;
	  if ( debounce == 5 ) {
	    logprintf("recalibrating the motor encoder offsets.\n");
	    // adjust the hipx offsets to a new assumed reference position, assuming the 
	    // robot is manually being held in the reference configuration
	    params.offset.q.hipx         +=  0.00 - s.q.hipx;

	    // the motors can rotate more than once per rotation, so assume that the springs are relaxed and just null
	    // the difference between the joint and motor encoders; this assumes that the joints have already been moved
	    // to find the index pulses
	    params.offset.q.l.hipymot    +=  s.q.l.hipy   - s.q.l.hipymot;
	    params.offset.q.l.kneemot    +=  s.q.l.knee   - s.q.l.kneemot;
	    params.offset.q.l.ankleymot  +=  s.q.l.ankley - s.q.l.ankleymot;
	    params.offset.q.r.hipymot    +=  s.q.r.hipy   - s.q.r.hipymot;
	    params.offset.q.r.kneemot    +=  s.q.r.knee   - s.q.r.kneemot;
	    params.offset.q.r.ankleymot  +=  s.q.r.ankley - s.q.r.ankleymot;
	    
	    mode_transition( MODE_STANDING );  
	  }
	} else {
	  debounce = 0;
	  c.LEDS &= ~LED1;
	}
      }

    // power down if the RUN/STOP switch goes to STOP
       if ( !FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE0 ) ) {
      c.LEDS &= ~LED0;
      mode_transition( MODE_POWER_DN_DRIVERS );
    } else {
	 update_exercise_controller(); // exercise.c
    }
    break;
    
    // Gait initiation controller; the code is in start_walking.c
  case MODE_START_WALKING:
    if ( mode_init ) {
      logprintf("entered initiation of walking mode.\n");
      c.walking.inx = 0;      // reset the controller state machine
      c.LEDS |= LED0;         // turn on the "controller active" LED
    }
    
    // power down if the RUN/STOP switch goes to STOP
    if ( !FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE0 ) ) {
      c.LEDS &= ~LED0;
      mode_transition( MODE_POWER_DN_DRIVERS );
    } else {
      update_start_walking_controller(); // start-walking.c
    }
    break;


  // walking controller; the code is in walk.c
  case MODE_WALKING:
    if ( mode_init ) {
      logprintf("entered walking mode.\n");
      c.walking.inx = 0;      // reset the controller state machine
      c.LEDS |= LED0;         // turn on the "controller active" LED
    }
    
    // power down if the RUN/STOP switch goes to STOP
    if ( !FLAME_TOGGLE_UP( s.front_panel_sw, TOGGLE0 ) ) {
      c.LEDS &= ~LED0;
      mode_transition( MODE_POWER_DN_DRIVERS );
    } else {
      update_walking_controller(); // walk.c

      // If a cable breaks, then stop the motors from turning or both sides of the cable will break
      if ((s.q.r.kneemot > 1.8) || (s.q.r.kneemot < -0.2)) { 
	s.tau.r.knee = 0.0;
      }
      if ((s.q.l.kneemot > 1.8) || (s.q.l.kneemot < -0.2)) { 
	s.tau.l.knee = 0.0;
      }
      if ((s.q.r.hipymot > 1.6) || (s.q.r.hipymot < -1.6)) { 
	s.tau.r.hipy = 0.0;
      }
      if ((s.q.l.hipymot > 1.6) || (s.q.l.hipymot < -1.6)) { 
	s.tau.l.hipy = 0.0;
      }
    }
    break;
} // end of the c.mode state machine

  /****************************************************************/
  // Update the outputs.  This is always done, even when the control is idle,
  // just to make it clear how much time it takes, and to avoid any worries
  // about leaving things powered during mode transitions.

  // Apply a tau limit. We obviously don't want a big torque going to our system!
  apply_tau_limit(  &s.tau.hipx,     HIPX_JOINT_RATIO,   HIPX_MOT_RATIO, 0);
  apply_tau_limit(  &s.tau.l.hipy,   HIPY_JOINT_RATIO,   HIPY_MOT_RATIO, c.joint.l.hipy.turbo_boost);
  apply_tau_limit(  &s.tau.l.knee,   KNEE_JOINT_RATIO,   KNEE_MOT_RATIO, 0);
  apply_tau_limit(  &s.tau.l.ankley, ANKLEY_JOINT_RATIO, ANKLEY_MOT_RATIO, c.joint.l.ankley.turbo_boost);
  apply_tau_limit(  &s.tau.r.hipy,   HIPY_JOINT_RATIO,   HIPY_MOT_RATIO, c.joint.r.hipy.turbo_boost);
  apply_tau_limit(  &s.tau.r.knee,   KNEE_JOINT_RATIO,   KNEE_MOT_RATIO, 0);
  apply_tau_limit(  &s.tau.r.ankley, ANKLEY_JOINT_RATIO, ANKLEY_MOT_RATIO, c.joint.r.ankley.turbo_boost);
  // for the ankles there is also a negative limit because they can only pull, not push. 
  // This limit is set to -1 to help the motor return on its own, not by the ankle.
  if ( s.tau.l.ankley < -1.0 ) { s.tau.l.ankley = -1.0; }
  if ( s.tau.r.ankley < -1.0 ) { s.tau.r.ankley = -1.0; }

  FlameIO_write_torque_commands( &io, &params, &s );
  FlameIO_enable_motor_drivers( &io, s.powered );
  FlameIO_set_front_panel_LEDS( &io, c.LEDS );
  FlameIO_set_motor_driver_LEDS( &io, c.LEDS >> NUMPANELLEDS );
    
  /****************************************************************/
  // Log data whenever anything is happening.

  if ( c.mode != MODE_IDLE ) 
    ring_buffer_snapshot(system_vars, ring_buffer);

  /****************************************************************/
  // General front panel interface (i.e., non-mode dependent)

  // the rightmost pushbutton is the "CLEAR DATA" button
  {
    static int button_debounce = 0;
    if ( FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON3 ) ) {
      button_debounce++;
      c.LEDS |= LED3;
      if ( button_debounce == 5 ) {
	logprintf("Clearing record buffer.\n");
	clear_ring_buffer( ring_buffer );
      }
    } else {
      button_debounce = 0;
      c.LEDS &= ~LED3;
    }
  }

  // If the left pushbutton is pressed begin to shutdown.
  if ( c.mode != MODE_BEGIN_SHUTDOWN && c.mode != MODE_SHUTDOWN &&
       FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON0 )) {
    c.mode = MODE_BEGIN_SHUTDOWN;
  }

  /****************************************************************/
  // Flash some LEDs.
  {
    static int count = 0;
    int fleds, mleds;
    fleds  = ( count++ & 0x200 ) ? LEDRIGHT : 0;
    mleds  = (count & 0x100) ? (FLAME_MLED_LEFT0 | FLAME_MLED_RIGHT1) : (FLAME_MLED_LEFT1 | FLAME_MLED_RIGHT0);
    c.LEDS = (c.LEDS & ~0x3c1) | (mleds << NUMPANELLEDS) | fleds;
  }

  /****************************************************************/
  // Communicate with host process.

  // Send a sensor data packet.
  sensormsg.header.type     = FLAME_MESSAGE;
  sensormsg.header.subtype  = MSG_SENSOR_DATA;
  sensormsg.header.length   = sizeof( struct sensor_message_t );
  sensormsg.serial_number   = next_serial++;
  sensormsg.local_protocol_version = LOCAL_MESSAGE_PROTOCOL_VERSION;

  memcpy( &sensormsg.state, &s, sizeof( sensormsg.state ) );       // copy all hardware state data into packet
  memcpy( &sensormsg.control, &c, sizeof( sensormsg.control ) );   // copy all controller state data into packet
  send_message ( rt_out_port, (union message_t *) &sensormsg);

  // Check for messages from host.
  if ( message_receive( rt_in_port, &msg ) ) {
    if (msg.header.type == FLAME_MESSAGE) {
      switch (msg.header.subtype) {  	// select based on subtype
	
      case MSG_PING:
	send_pong( rt_out_port );
	break;

      case MSG_SHUTDOWN: 
	// begin to shutdown; this could allow some time for some cleanup or shutdown activity
	c.mode = MODE_BEGIN_SHUTDOWN;
	break;

      case MSG_IMU_DATA:
	{
	  struct imu_data_message_t *data = (struct imu_data_message_t *) &msg;
	  c.imu.samples = data->samples;
	  c.imu.yaw     = data->yaw;
	  c.imu.pitch   = data->pitch;
	  c.imu.roll    = data->roll;
	}
	break;
	  
      default:
	break;
      }
    }
  }

  /****************************************************************/
  // Finish the cycle.
  c.timing.sensor_processing = 1e-9 * (end_of_sensor_reading - start_of_cycle);
  end_of_cycle = rt_get_cpu_time_ns();
  c.timing.total_cycle       = 1e-9 * (end_of_cycle - start_of_cycle);

  // Run until SHUTDOWN mode is entered.
  return ( c.mode != MODE_SHUTDOWN ); // true means keep running
}

/****************************************************************/
int main(int argc, char **argv)
{
  int i;

  // Initialize velocity estimators memory
  // This is actually a small hack. The qprev stays within this programme and isn't 
  // a global variable. That is why it is possible to initialize this before all the 
  // IO and RTAI stuff is initialized.
  init_velocity_memory();

  logprintf("control for Flame.\n");
  logprintf("This is meant to be run on the PC/104 stack for the Flame Biped.\n");
  logprintf("This uses the RTAI real time system, which must already be loaded.\n");

  if (!RTAI_is_ready()) {
    errprintf("Didn't find RTAI module, quitting.\n");
    exit(1);
  }

  force_stack_growth();

  logprintf( "%s: Opening up all Flame I/O hardware.\n", NAME);
  FlameIO_init ( &io );

  if (!FlameIO_is_ready( &io ) ) {
    errprintf("The Flame I/O devices failed to fully initialize.\n");
    goto fail;
  }

  // Initialize our offset and scale structures.
  FlameIO_initialize_default_state( &s );
  FlameIO_initialize_default_parameters( &params );

  // Initialize default control state.  Do this before PARAMS is
  // read so the file can override the default values.
  initialize_control_state();
 
  // Read a parameter file, if present.
  if ( system_state_var_array_set_from_file( system_vars, "PARAMS" ) ) {
    errprintf("unable to open parameter file: %s\n", strerror(errno));
  } else {
    logprintf("loaded parameter file.\n");
  }

#if USE_DMALLOC
  logprintf("checking heap.\n");
  dmalloc_verify( 0L );  // check the heap status
#endif

  // Create a ring buffer to log data.  This will create a
  // storage buffer for every variable, including those which are
  // not written to files because the archivable bit is cleared.
  // If memory becomes a limitation, this function could be
  // extended to skip creating the data buffer for marked
  // variables, however, the snapshot code also would need to be
  // fixed, since it depends upon a one to one correspondence
  // between system_vars and the rows the ring buffer.
  ring_buffer = create_ring_buffer( system_vars, RINGLEN );

  // Unmark some of the static variables so they won't be
  // recorded in the data file; this keeps the data files
  // smaller.
  {
    int v;
    regex_t pattern1;
    int pattern1_valid = 0;
    int err;

    for ( v = 0; v < ring_buffer->variables; v++ ) {
      char *varname = ring_buffer->vars[v].name;
      
      // Now mention the parts that are not needed to store in data-files:
      if ( !strncmp( varname, "offset", 6) ||
	   !strncmp( varname, "scale", 5) || 
	   !strncmp( varname, "taumax", 6) ||
	   !strncmp( varname, "exercise", 8) ||
	   !strncmp( varname, "timing", 6) ||
	   !strncmp( varname, "imu", 3) ||
	   !strncmp( varname, "standing", 8) ||
	   !strncmp( varname, "demo", 4) ||
	   !strncmp( varname, "k.", 2) ||
	   !strncmp( varname, "dt", 2) ||
	   !strncmp( varname, "LEDS", 4) ||
	   ( pattern1_valid && !regexec( &pattern1, varname, 0, NULL, 0 )) ||
	   0 ) {
	// printf("%s will not be saved in files.\n", varname );
	ring_buffer->vars[v].archivable = 0;
      }
    }
    // Omitting the regfree is a minor memory leak, but for some reason it is segfaulting.
    // if (pattern1_valid) regfree( &pattern1 );
  }

#if USE_DMALLOC
  logprintf("checking heap.\n");
  dmalloc_verify( 0L );  // check the heap status
#endif

  // Initialize the real time interface.
  logprintf("%s: initializing RTAI real time interface.\n", NAME);

  // start up the real time system
  control_task = create_RTAI_user_space_task( REALTIME_PROCESS_NAME );
  if ( control_task == NULL ) {
    errprintf("Failed to initialize RTAI interface.\n");
    goto fail;
  }

#if USE_DMALLOC
  logprintf("checking heap.\n");
  dmalloc_verify( 0L );  // check the heap status
#endif

  // Create communications queues to interact with a non-real-time process.
  logprintf("%s: opening mailboxes.\n", NAME); fflush(stdout);
  rt_out_port = init_RTAI_mailbox_message_port( message_port_alloc(), REALTIME_OUTPUT_MAILBOX_NAME );
  rt_in_port = init_RTAI_mailbox_message_port( message_port_alloc(), REALTIME_INPUT_MAILBOX_NAME );

  if ( rt_out_port == NULL ) {
    errprintf("Real time task unable to create message port.\n");
    shutdown_RTAI_user_space_task( control_task );
    goto fail;
  }

  // Make sure the inbox has nothing left from other programs or a previous run.
  {
    int count = 0;
    union message_t msg;
    while ( message_receive( rt_in_port, &msg ) ) count++;
    if ( count > 0 ) logprintf("%s: Flushed %d messages from input port.\n", NAME, count);
  }

#if USE_DMALLOC
  logprintf("checking heap.\n");
  dmalloc_verify( 0L );  // check the heap status
#endif

  // Run the real time thread until it exits.  
  logprintf("%s: starting real time thread.\n ==> It will run until the left pushbutton is pressed.\n", NAME); 
  fflush(stdout);

  // switch to real-time console stream
  console_on_ports = 1;

  // run the controller until it completes
  run_RTAI_user_space_realtime_periodic_thread( control_task, realtime_thread, TIMER_PERIOD /* nanoseconds */, NULL /* user data */);

  // switch back to normal stdout
  console_on_ports = 0;

  // It exited, now clean up.
  logprintf("%s: Real time thread exited.\n", NAME);
  message_port_dealloc( rt_out_port );
  message_port_dealloc( rt_in_port );
  RTAI_usr_print_task_statistics( control_task );
  shutdown_RTAI_user_space_task( control_task );

  // Save the final state of the ring buffer if indicated.  I'm
  // not sure why, but the opendir() within new_data_file_name()
  // within write_ring_buffer() was seg-faulting when this action
  // happened later, so it happens now before any threads shut
  // down; I suspect it is a thread safety bug.  Update:
  // the threads have been moved out of this file, so this may
  // not matter.

  if ( FLAME_TOGGLE_UP(s.front_panel_sw, TOGGLE3) && ring_buffer != NULL) {
    char *name;

    logprintf( "%s: Saving data.\n", NAME);
    name = write_ring_buffer(ring_buffer);

    if ( name == NULL ) {
      errprintf("Failed to write data file: %s\n", strerror(errno));
    } else {
      char *paramsfile;
      asprintf(&paramsfile, "%s-PARAMS", name );
      system_state_var_array_save_to_file( system_vars, paramsfile );
      logprintf("Saved data in %s and %s.\n", name, paramsfile);
      free ( name );
      free ( paramsfile );
    }

  } else {
    logprintf("Logging not enabled, nothing saved.\n");
  }

  logprintf( "%s: Shutting down Flame I/O.\n", NAME);
  FlameIO_close( &io );

 // final farewell
  logprintf("\n%s done.\n", NAME);  
  exit(0);

  // a variety of failures end here
 fail:
  FlameIO_close( &io );
  logprintf("\n%s quitting.\n", NAME);  
  exit(1);
}
