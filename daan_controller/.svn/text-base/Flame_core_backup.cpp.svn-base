// $Id: control_demo.c,v 1.12 2005/12/16 16:14:22 garthz Exp $
// control_demo : a demonstration controller for the Flame biped robot
//
// Copyright (c) 2005 Garth Zeglin. Provided under the terms of the
// GNU General Public License as included in the top level directory.
//
// This file defines front panel switches as follows:
//
//		TOGGLE0		TOGGLE1		TOGGLE2		TOGGLE3
//		controller			                save data
//		on/off						up = yes

//		PUSHBUTTON0	PUSHBUTTON1	PUSHBUTTON2	PUSHBUTTON3	
//		shutdown	         	        	clear


#include <stdio.h>
#include <asm/io.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#include <math.h>
#include <string.h>
#include <pthread.h>
#include <stdarg.h>
#include <signal.h>
#include <sys/types.h>
#include <regex.h>

#if USE_DMALLOC
#include <dmalloc.h>   // malloc debugging
#endif

#include <rtai_lxrt.h>

#include <hardware_drivers/FlameIO.h>
#include <utility/utility.h>
#include <utility/dataset.h>
#include <utility/record.h>

//#include <utility/system_state_var.h>

#include <real_time_support/RTAI_user_space_realtime.h>
#include <real_time_support/RTAI_mailbox_messaging.h>
#include <real_time_support/UDP_messaging.h>
#include <real_time_support/protocol_version.h>

// definitions for the big structures of control state
#include <hardware_drivers/FlameIO_defs.h>

// application header files
//#include "system.h"
#include "local_protocol_version.h"
#include "message_format.h"
#include "Flame_core.h"

/****************************************************************/
#define SAMPLING_RATE 1000      // Hz
#define TIMER_PERIOD (1000000000 / SAMPLING_RATE )  // nsec
#define CONTROL_DT    (1.0 / SAMPLING_RATE)         // seconds

#define NAME "Flame_core"

// opaque handle for the real time control thread task
static struct realtime_task *control_task = NULL;

/****************************************************************/
FlameIO_state_t s;        // the global hardware state structure (i.e. blackboard)
FlameIO_params_t params;  // the hardware parameters structure 
// controller_state_t c;     // the controller state blackboard
CFlameJoints joints;

// Define a table which describes the name and location of the
// global state variables.  The entries are generated by
// different makevars scripts.



// ****************************************************************************************************************VRAGEN AAN ERIK
static system_state_var_t system_vars[] = 
{
	// include entries generated for our controller code
	#include "sysvars.h"

	// include entries generated for the hardware driver code
	#include <hardware_drivers/FlameIO_sysvars.h>

	// a final entry to mark the end of the list
	{ NULL, SYS_NOTYPE, NULL }
};


/****************************************************************/
// Data logging buffer
#define RINGLEN 30000    // 30 seconds at 1 kHz

// *****************************************************************************************************************VRAGEN AAN ERIK
static dataset_t *ring_buffer = NULL;

/****************************************************************/
static FlameIO io;               // a static area to hold the driver data

// Pointers to message queues.
static message_port *rt_out_port = NULL;   
static message_port *rt_in_port = NULL;

// Flag to indicate destination of console messages.
static int console_on_ports = 0;

/****************************************************************/
// Provide a local version of errprintf to override the one in
// the utility library.  This is necessary so that the normal Linux system
// calls are not used.

#define CONSOLE_BUFFER_LENGTH 1024
static char console_buffer[ CONSOLE_BUFFER_LENGTH ];

void errprintf(char *format, ...)
{
  va_list args;
  va_start( args, format);

  if ( !console_on_ports ) {
    // Normal stdout stream output.  Add a header with a name and a time stamp.
    char nowstr[26];
    time_t now = time(NULL);

    strncpy( nowstr, ctime(&now)+11, 8);   // ctime format: "Wed Jun 30 21:49:08 1993\n"
    nowstr[8] = 0;
    fprintf(stderr, "%s error %s: ", NAME, nowstr);
    vfprintf(stderr, format, args);
    fflush(stderr);

  } else {
    // Send console messages through the real time ports. The
    // origin of the messages will be obvious from context, no
    // need to add the program name.
    strcpy( console_buffer, "error: ");
    vsnprintf( console_buffer + strlen( console_buffer ), CONSOLE_BUFFER_LENGTH - strlen( console_buffer), format, args );
    send_print( rt_out_port, console_buffer );
  }
  va_end(args);
}

/****************************************************************/
// Provide a local version of logprintf to override the one in
// the utility library.
void logprintf(char *format, ...)
{
  va_list args;
  va_start(args, format);

  if ( !console_on_ports ) {
    // normal stdout stream
    fprintf(stdout, "%s: ", NAME);
    vfprintf(stdout, format, args);
    fflush(stderr);

  } else {
    // Send console messages through the real time ports. The
    // origin of the messages will be obvious from context, no
    // need to add a header.
    vsnprintf( console_buffer, CONSOLE_BUFFER_LENGTH, format, args );
    send_print( rt_out_port, console_buffer );
  }

  va_end(args);
}


/****************************************************************/
// This may help avoid page faults, see the mlockall man page.
static void force_stack_growth(void)
{
  #define STACKINCREMENT 100*1024
  char large_array[ STACKINCREMENT ];
  large_array[ STACKINCREMENT-1 ] = 0x55;
}

/****************************************************************/
// define the matrix with the previous q's here. They are needed for the velocity estimator.
// They are defined here so they will not go to the ring buffer and therefore will not consume that much memory.
// However, after using this for a couple of times it turned out that the processor load went from 45% to 65%!
// This is probably due to the style of programming. If you know how to improve it... please do so.

# define LENGTH_QPREV 10 //10 might be short, but is maintained for now due to the extra processor load it requires

static float hipx_qprev[ LENGTH_QPREV ];
static float l_hipy_qprev[ LENGTH_QPREV ];
static float l_knee_qprev[ LENGTH_QPREV ];
static float l_anklex_qprev[ LENGTH_QPREV ];
static float l_ankley_qprev[ LENGTH_QPREV ];
static float l_hipymot_qprev[ LENGTH_QPREV ];
static float l_kneemot_qprev[ LENGTH_QPREV ];
static float l_ankleymot_qprev[ LENGTH_QPREV ];
static float r_hipy_qprev[ LENGTH_QPREV ];
static float r_knee_qprev[ LENGTH_QPREV ];
static float r_anklex_qprev[ LENGTH_QPREV ];
static float r_ankley_qprev[ LENGTH_QPREV ];
static float r_hipymot_qprev[ LENGTH_QPREV ];
static float r_kneemot_qprev[ LENGTH_QPREV ];
static float r_ankleymot_qprev[ LENGTH_QPREV ];


/****************************************************************/
// A velocity estimator with adaptive windowing to recover velocity from encoders.
// This is inline code which is based on the algorithm of Janabi-Sharifi and Hayward (2000).
static inline void apply_velocity_estimator( float (*q_temp)[ LENGTH_QPREV ], float *q, float *qd, float *d, float dt )
{ 
  int i = 1;
  int m = 1;
  int all_points_within_uncertaintyband = 1;
  float diff = 0.0;
  float q_interp = 0.0;
  float b = 0.0;
  float sum = *q;
  float sumtot = 0.0;
  for ( i = 1; ( all_points_within_uncertaintyband == 1 && i < (LENGTH_QPREV+1) ) ; i++ ){       

    sum += (*q_temp)[i-1];
    sumtot += (*q_temp)[i-1] * i;                  // step 2 needed for best fit FOAW
    b = (i*sum-2*sumtot)/(dt*(i+2)*i*(i+1)/6);     // step 2 and 3 of paper "Janabi-Sharifi-2000.pdf"

    for ( m = 1; m < i; m++ ) {
      q_interp = *q - b*m*dt; 
      diff = q_interp - (*q_temp)[m-1];

      // step 4, if the b-line doesnt go trough the uncertainty band window (either above or below)
      if ((diff*diff) > 2*(*d*(*d)) ) {              // comparing the absolute values // 2times is a test 
	  all_points_within_uncertaintyband = 0;
	  break;
	}
      }
  }
  *qd = b;

  // shift the q in the q_temp-matrix down
  for (i = 1; i < LENGTH_QPREV; i++){
    (*q_temp)[i] = (*q_temp)[i-1];
  }

  (*q_temp)[0]   = *q;
}

/*******************************************************************/
// Now check if it works by comparing it to the old velocity estimator
static inline void apply_velocity_estimator_old ( float (*q_temp)[LENGTH_QPREV], float *q, float *qdold )
{   
  float diff =  *q - (*q_temp)[1]; // q_prev was already shifted down by the new *q, so q_prev[1] is the latest one before *q
  *qdold = diff / CONTROL_DT;
}
/*******************************************************************/
// Compute the velocity estimator for all encoder inputs.
static void update_velocity_estimators(void)
{
  apply_velocity_estimator( &hipx_qprev       , &s.hipx.q       , &s.hipx.qd       , &params.scale.q.hipx       , s.dt);
  apply_velocity_estimator( &l_hipy_qprev     , &s.l.hipy.q     , &s.l.hipy.qd     , &params.scale.q.l.hipy     , s.dt);
  apply_velocity_estimator( &l_knee_qprev     , &s.l.knee.q     , &s.l.knee.qd     , &params.scale.q.l.knee     , s.dt);
  apply_velocity_estimator( &l_ankley_qprev   , &s.l.ankley.q   , &s.l.ankley.qd   , &params.scale.q.l.ankley   , s.dt);
  apply_velocity_estimator( &l_anklex_qprev   , &s.l.anklex.q   , &s.l.anklex.qd   , &params.scale.q.l.anklex   , s.dt);
  apply_velocity_estimator( &l_hipymot_qprev  , &s.l.hipymot.q  , &s.l.hipymot.qd  , &params.scale.q.l.hipymot  , s.dt);
  apply_velocity_estimator( &l_kneemot_qprev  , &s.l.kneemot.q  , &s.l.kneemot.qd  , &params.scale.q.l.kneemot  , s.dt);
  apply_velocity_estimator( &l_ankleymot_qprev, &s.l.ankleymot.q, &s.l.ankleymot.qd, &params.scale.q.l.ankleymot, s.dt);
  apply_velocity_estimator( &r_hipy_qprev     , &s.r.hipy.q     , &s.r.hipy.qd     , &params.scale.q.r.hipy     , s.dt);
  apply_velocity_estimator( &r_knee_qprev     , &s.r.knee.q     , &s.r.knee.qd     , &params.scale.q.r.knee     , s.dt);
  apply_velocity_estimator( &r_ankley_qprev   , &s.r.ankley.q   , &s.r.ankley.qd   , &params.scale.q.r.ankley   , s.dt);
  apply_velocity_estimator( &r_anklex_qprev   , &s.r.anklex.q   , &s.r.anklex.qd   , &params.scale.q.r.anklex   , s.dt);
  apply_velocity_estimator( &r_hipymot_qprev  , &s.r.hipymot.q  , &s.r.hipymot.qd  , &params.scale.q.r.hipymot  , s.dt);
  apply_velocity_estimator( &r_kneemot_qprev  , &s.r.kneemot.q  , &s.r.kneemot.qd  , &params.scale.q.r.kneemot  , s.dt);
  apply_velocity_estimator( &r_ankleymot_qprev, &s.r.ankleymot.q, &s.r.ankleymot.qd, &params.scale.q.r.ankleymot, s.dt);

  // To see the difference with the old velocity estimator. This can be deleted when it turns out that the new one works better
  apply_velocity_estimator_old( &hipx_qprev      , &s.hipx.q     , &s.hipx.qdold     );
  apply_velocity_estimator_old( &l_hipy_qprev    , &s.l.hipy.q   , &s.l.hipy.qdold   );
  apply_velocity_estimator_old( &l_knee_qprev    , &s.l.knee.q   , &s.l.knee.qdold   ); 
  apply_velocity_estimator_old( &l_ankley_qprev  , &s.l.ankley.q , &s.l.ankley.qdold ); 
  apply_velocity_estimator_old( &l_anklex_qprev  , &s.l.anklex.q , &s.l.anklex.qdold );
  apply_velocity_estimator_old( &r_hipy_qprev    , &s.r.hipy.q   , &s.r.hipy.qdold   );
  apply_velocity_estimator_old( &r_knee_qprev    , &s.r.knee.q   , &s.r.knee.qdold   );
  apply_velocity_estimator_old( &r_ankley_qprev  , &s.r.ankley.q , &s.r.ankley.qdold ); 
  apply_velocity_estimator_old( &r_anklex_qprev  , &s.r.anklex.q , &s.r.anklex.qdold );
  
}
/****************************************************************/
// Fill vel_estim with zeros
static inline void fill_velocity_memory ( float (*qprev)[ LENGTH_QPREV ] )
{
  int k;
  for ( k = 0; k < LENGTH_QPREV ; k++ ){
    (*qprev)[k] = 0.0;
  }
}
 
/****************************************************************/
// Initialize the velocity memory. This matrix needs to be filled 
// with many zeros before the controller starts.
static void init_velocity_memory(void)
{
  fill_velocity_memory( &hipx_qprev        );
  fill_velocity_memory( &l_hipy_qprev      );
  fill_velocity_memory( &l_knee_qprev      );
  fill_velocity_memory( &l_ankley_qprev    );
  fill_velocity_memory( &l_anklex_qprev    );
  fill_velocity_memory( &l_hipymot_qprev   );
  fill_velocity_memory( &l_kneemot_qprev   );
  fill_velocity_memory( &l_ankleymot_qprev );
  fill_velocity_memory( &r_hipy_qprev      );
  fill_velocity_memory( &r_knee_qprev      );
  fill_velocity_memory( &r_ankley_qprev    );
  fill_velocity_memory( &r_anklex_qprev    );
  fill_velocity_memory( &r_hipymot_qprev   );
  fill_velocity_memory( &r_kneemot_qprev   );
  fill_velocity_memory( &r_ankleymot_qprev );
}

/****************************************************************/
// Initialize default control state.  This is done before PARAMS
// is read so the file can override the default values.
static void initialize_control_state (void)
{
  s.t = 0;
  s.dt = CONTROL_DT;

  s.timing.sensor_processing = 0.001;
  s.timing.total_cycle = 0.001;
  s.LEDS = 0;

  // initialize the various controller pieces
  joints.Init(); // FlameJoints.cpp
  gFlameController.Init(); // CtrlFlame.cpp
  gStandingController.Init(); // CtrlStanding.cpp
  gWalkingController.Init(); // CtrlWalking.cpp
  gExerciseController.Init(); // CtrlExercise.cpp

}
/****************************************************************/
// Applying a tau limit to the controller.
static inline void apply_tau_limit( float *tau, float joint_ratio, float gear_ratio, int turbo_boost )
{
  // The limit is determined by the max amount of current (2.75 A)
  float max_current = 2.75;  
  float limit = 0.0;
  if (turbo_boost) max_current = 4.0;
  limit = max_current * MAXON_RE35_TORQUE_CONSTANT * joint_ratio * gear_ratio;
  if ( *tau >  limit ) { *tau =  limit; }
  if ( *tau < -limit ) { *tau = -limit; }
}
/*
/****************************************************************
// Utility to help manage the mode state machine.
static inline void mode_transition( int newmode )
{
  c.mode = -newmode;
  c.t_mode = c.t;    // record a timestamp
}
static float mode_time_elapsed( void )
{
  return c.t - c.t_mode;
}
*/

/****************************************************************/
// This function will be called at regular intervals.
// No system calls are allowed inside this function. 
// This function returns true if the periodic calls should continue.

static int realtime_thread( long long timestamp, void *userdata )
{
  static int next_serial = 0;

  // Time stamp to provide an origin for the time axis.
  static RTIME start_of_execution;
  static int start_of_execution_valid = 0; 
  
  struct sensor_message_t sensormsg;
  union message_t msg;
  RTIME start_of_cycle, end_of_sensor_reading, end_of_cycle;
  int channel;
  int mode_init = 0;      // true if a mode is being executed for the first iteration

  /****************************************************************/
  // Read all inputs.
  start_of_cycle = (RTIME) timestamp;
  FlameIO_read_all_sensors( &io, &params, &s );
  end_of_sensor_reading = rt_get_cpu_time_ns();

  // Capture the time of the first iteration
  if ( !start_of_execution_valid ) {
    start_of_execution = start_of_cycle;
    start_of_execution_valid = 1;
  }

  // Extract a clock value in seconds.
  s.t = 1e-9 * (start_of_cycle - start_of_execution);

  /****************************************************************/
  // Perform all control actions.
  update_velocity_estimators();

  /*
  // Filter the motor voltage with a simple clamped first order filter.
  {
    float err = s.battery.mot_sw - c.mot_sw_filt;
    if ( err > 2.0 ) err = 2.0 ; else if ( err < -2.0 ) err = -2.0;
    c.mot_sw_filt += 0.1 * err;  // simple first order filter
  }    
  */

	//********************************************************************//
	//*********** THE MAIN STATE MACHINE *********************************//
	//********************************************************************//

	// Update the Flame state machine
	gFlameController.Update();

	//********************************************************************//
	//********* END OF THE MAIN STATE MACHINE ****************************//
	//********************************************************************//



  /****************************************************************/
  // Update the outputs.  This is always done, even when the control is idle,
  // just to make it clear how much time it takes, and to avoid any worries
  // about leaving things powered during mode transitions.

  // Apply a tau limit. We obviously don't want a big torque going to our system!
  apply_tau_limit(  &s.tau.hipx,     HIPX_JOINT_RATIO,   HIPX_MOT_RATIO, 0);
  apply_tau_limit(  &s.tau.l.hipy,   HIPY_JOINT_RATIO,   HIPY_MOT_RATIO, joints.l().hipy.turbo_boost);
  apply_tau_limit(  &s.tau.l.knee,   KNEE_JOINT_RATIO,   KNEE_MOT_RATIO, 0);
  apply_tau_limit(  &s.tau.l.ankley, ANKLEY_JOINT_RATIO, ANKLEY_MOT_RATIO, joints.l().ankley.turbo_boost);
  apply_tau_limit(  &s.tau.r.hipy,   HIPY_JOINT_RATIO,   HIPY_MOT_RATIO, joints.r().hipy.turbo_boost);
  apply_tau_limit(  &s.tau.r.knee,   KNEE_JOINT_RATIO,   KNEE_MOT_RATIO, 0);
  apply_tau_limit(  &s.tau.r.ankley, ANKLEY_JOINT_RATIO, ANKLEY_MOT_RATIO, joints.r().ankley.turbo_boost);
  // for the ankles there is also a negative limit because they can only pull, not push. 
  // This limit is set to -1 to help the motor return on its own, not by the ankle.
  if ( s.tau.l.ankley < -1.0 ) { s.tau.l.ankley = -1.0; }
  if ( s.tau.r.ankley < -1.0 ) { s.tau.r.ankley = -1.0; }

  FlameIO_write_torque_commands( &io, &params, &s );
  FlameIO_enable_motor_drivers( &io, s.powered );
  FlameIO_set_front_panel_LEDS( &io, s.LEDS );
  FlameIO_set_motor_driver_LEDS( &io, s.LEDS >> NUMPANELLEDS );
    
  /****************************************************************/
  // Log data whenever anything is happening.

  if ( !gFlameController.IsInState(&gFlame_StIdle)) 
    ring_buffer_snapshot(system_vars, ring_buffer);

  /****************************************************************/
  // General front panel interface (i.e., non-mode dependent)

  // the rightmost pushbutton is the "CLEAR DATA" button
  {
    static int button_debounce = 0;
    if ( FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON3 ) ) {
      button_debounce++;
      s.LEDS |= LED3;
      if ( button_debounce == 5 ) {
	logprintf("Clearing record buffer.\n");
	clear_ring_buffer( ring_buffer );
      }
    } else {
      button_debounce = 0;
      s.LEDS &= ~LED3;
    }
  }

  // If the left pushbutton is pressed begin to shutdown.
  if ( !gFlameController.IsInState(&gFlame_StBeginShutdown) && !gFlameController.ShouldShutdown() &&
       FLAME_PUSHBUTTON_PRESSED( s.front_panel_sw, PUSHBUTTON0 )) 
  {
	  gFlameController.Transition(&gFlame_StBeginShutdown);
  }

  /****************************************************************/
  // Flash some LEDs.
  {
    static int count = 0;
    int fleds, mleds;
    fleds  = ( count++ & 0x200 ) ? LEDRIGHT : 0;
    mleds  = (count & 0x100) ? (FLAME_MLED_LEFT0 | FLAME_MLED_RIGHT1) : (FLAME_MLED_LEFT1 | FLAME_MLED_RIGHT0);
    s.LEDS = (s.LEDS & ~0x3c1) | (mleds << NUMPANELLEDS) | fleds;
  }

  /****************************************************************/
  // Communicate with host process.

  // Send a sensor data packet.
  sensormsg.header.type     = FLAME_MESSAGE;
  sensormsg.header.subtype  = MSG_SENSOR_DATA;
  sensormsg.header.length   = sizeof( struct sensor_message_t );
  sensormsg.serial_number   = next_serial++;
  sensormsg.local_protocol_version = LOCAL_MESSAGE_PROTOCOL_VERSION;

  memcpy( &sensormsg.state, &s, sizeof( sensormsg.state ) );       // copy all hardware state data into packet

  // *************************************************************************************************************************VRAGEN AAN ERIK
  memcpy( &sensormsg.control, &c, sizeof( sensormsg.control ) );   // copy all controller state data into packet
  send_message ( rt_out_port, (union message_t *) &sensormsg);

  // Check for messages from host.
  if ( message_receive( rt_in_port, &msg ) ) {
    if (msg.header.type == FLAME_MESSAGE) {
      switch (msg.header.subtype) {  	// select based on subtype
	
      case MSG_PING:
	send_pong( rt_out_port );
	break;

      case MSG_SHUTDOWN: 
	// begin to shutdown; this could allow some time for some cleanup or shutdown activity
	gFlameController.Transition(&gFlame_StBeginShutdown);
	break;

      case MSG_IMU_DATA:
	{
	  struct imu_data_message_t *data = (struct imu_data_message_t *) &msg;
	  s.imu.samples = data->samples;
	  s.imu.yaw     = data->yaw;
	  s.imu.pitch   = data->pitch;
	  s.imu.roll    = data->roll;
	}
	break;
	  
      default:
	break;
      }
    }
  }

  /****************************************************************/
  // Finish the cycle.
  s.timing.sensor_processing = 1e-9 * (end_of_sensor_reading - start_of_cycle);
  end_of_cycle = rt_get_cpu_time_ns();
  s.timing.total_cycle       = 1e-9 * (end_of_cycle - start_of_cycle);

  // Run until SHUTDOWN mode is entered.
  return ( !gFlameController.ShouldShutdown() ); // true means keep running
}

/****************************************************************/
int main(int argc, char **argv)
{
  int i;

  // Initialize velocity estimators memory
  // This is actually a small hack. The qprev stays within this programme and isn't 
  // a global variable. That is why it is possible to initialize this before all the 
  // IO and RTAI stuff is initialized.
  init_velocity_memory();

  logprintf("control for Flame.\n");
  logprintf("This is meant to be run on the PC/104 stack for the Flame Biped.\n");
  logprintf("This uses the RTAI real time system, which must already be loaded.\n");

  if (!RTAI_is_ready()) {
    errprintf("Didn't find RTAI module, quitting.\n");
    exit(1);
  }

  force_stack_growth();

  logprintf( "%s: Opening up all Flame I/O hardware.\n", NAME);
  FlameIO_init ( &io );

  if (!FlameIO_is_ready( &io ) ) {
    errprintf("The Flame I/O devices failed to fully initialize.\n");
    goto fail;
  }

  // Initialize our offset and scale structures.
  FlameIO_initialize_default_state( &s );
  FlameIO_initialize_default_parameters( &params );

  // Initialize default control state.  Do this before PARAMS is
  // read so the file can override the default values.
  initialize_control_state();
 
  // Read a parameter file, if present.
  if ( system_state_var_array_set_from_file( system_vars, "PARAMS" ) ) {
    errprintf("unable to open parameter file: %s\n", strerror(errno));
  } else {
    logprintf("loaded parameter file.\n");
  }

#if USE_DMALLOC
  logprintf("checking heap.\n");
  dmalloc_verify( 0L );  // check the heap status
#endif

  // Create a ring buffer to log data.  This will create a
  // storage buffer for every variable, including those which are
  // not written to files because the archivable bit is cleared.
  // If memory becomes a limitation, this function could be
  // extended to skip creating the data buffer for marked
  // variables, however, the snapshot code also would need to be
  // fixed, since it depends upon a one to one correspondence
  // between system_vars and the rows the ring buffer.
  ring_buffer = create_ring_buffer( system_vars, RINGLEN );

  // Unmark some of the static variables so they won't be
  // recorded in the data file; this keeps the data files
  // smaller.
  {
    int v;
    regex_t pattern1;
    int pattern1_valid = 0;
    int err;

    for ( v = 0; v < ring_buffer->variables; v++ ) {
      char *varname = ring_buffer->vars[v].name;
      
      // Now mention the parts that are not needed to store in data-files:
      if ( !strncmp( varname, "offset", 6) ||
	   !strncmp( varname, "scale", 5) || 
	   !strncmp( varname, "taumax", 6) ||
	   !strncmp( varname, "exercise", 8) ||
	   !strncmp( varname, "timing", 6) ||
	   !strncmp( varname, "imu", 3) ||
	   !strncmp( varname, "standing", 8) ||
	   !strncmp( varname, "demo", 4) ||
	   !strncmp( varname, "k.", 2) ||
	   !strncmp( varname, "dt", 2) ||
	   !strncmp( varname, "LEDS", 4) ||
	   ( pattern1_valid && !regexec( &pattern1, varname, 0, NULL, 0 )) ||
	   0 ) {
	// printf("%s will not be saved in files.\n", varname );
	ring_buffer->vars[v].archivable = 0;
      }
    }
    // Omitting the regfree is a minor memory leak, but for some reason it is segfaulting.
    // if (pattern1_valid) regfree( &pattern1 );
  }

#if USE_DMALLOC
  logprintf("checking heap.\n");
  dmalloc_verify( 0L );  // check the heap status
#endif

  // Initialize the real time interface.
  logprintf("%s: initializing RTAI real time interface.\n", NAME);

  // start up the real time system
  control_task = create_RTAI_user_space_task( REALTIME_PROCESS_NAME );
  if ( control_task == NULL ) {
    errprintf("Failed to initialize RTAI interface.\n");
    goto fail;
  }

#if USE_DMALLOC
  logprintf("checking heap.\n");
  dmalloc_verify( 0L );  // check the heap status
#endif

  // Create communications queues to interact with a non-real-time process.
  logprintf("%s: opening mailboxes.\n", NAME); fflush(stdout);
  rt_out_port = init_RTAI_mailbox_message_port( message_port_alloc(), REALTIME_OUTPUT_MAILBOX_NAME );
  rt_in_port = init_RTAI_mailbox_message_port( message_port_alloc(), REALTIME_INPUT_MAILBOX_NAME );

  if ( rt_out_port == NULL ) {
    errprintf("Real time task unable to create message port.\n");
    shutdown_RTAI_user_space_task( control_task );
    goto fail;
  }

  // Make sure the inbox has nothing left from other programs or a previous run.
  {
    int count = 0;
    union message_t msg;
    while ( message_receive( rt_in_port, &msg ) ) count++;
    if ( count > 0 ) logprintf("%s: Flushed %d messages from input port.\n", NAME, count);
  }

#if USE_DMALLOC
  logprintf("checking heap.\n");
  dmalloc_verify( 0L );  // check the heap status
#endif

  // Run the real time thread until it exits.  
  logprintf("%s: starting real time thread.\n ==> It will run until the left pushbutton is pressed.\n", NAME); 
  fflush(stdout);

  // switch to real-time console stream
  console_on_ports = 1;

  // run the controller until it completes
  run_RTAI_user_space_realtime_periodic_thread( control_task, realtime_thread, TIMER_PERIOD /* nanoseconds */, NULL /* user data */);

  // switch back to normal stdout
  console_on_ports = 0;

  // It exited, now clean up.
  logprintf("%s: Real time thread exited.\n", NAME);
  message_port_dealloc( rt_out_port );
  message_port_dealloc( rt_in_port );
  RTAI_usr_print_task_statistics( control_task );
  shutdown_RTAI_user_space_task( control_task );

  // Save the final state of the ring buffer if indicated.  I'm
  // not sure why, but the opendir() within new_data_file_name()
  // within write_ring_buffer() was seg-faulting when this action
  // happened later, so it happens now before any threads shut
  // down; I suspect it is a thread safety bug.  Update:
  // the threads have been moved out of this file, so this may
  // not matter.

  if ( FLAME_TOGGLE_UP(s.front_panel_sw, TOGGLE3) && ring_buffer != NULL) {
    char *name;

    logprintf( "%s: Saving data.\n", NAME);
    name = write_ring_buffer(ring_buffer);

    if ( name == NULL ) {
      errprintf("Failed to write data file: %s\n", strerror(errno));
    } else {
      char *paramsfile;
      asprintf(&paramsfile, "%s-PARAMS", name );
      system_state_var_array_save_to_file( system_vars, paramsfile );
      logprintf("Saved data in %s and %s.\n", name, paramsfile);
      free ( name );
      free ( paramsfile );
    }

  } else {
    logprintf("Logging not enabled, nothing saved.\n");
  }

  logprintf( "%s: Shutting down Flame I/O.\n", NAME);
  FlameIO_close( &io );

 // final farewell
  logprintf("\n%s done.\n", NAME);  
  exit(0);

  // a variety of failures end here
 fail:
  FlameIO_close( &io );
  logprintf("\n%s quitting.\n", NAME);  
  exit(1);
}
